<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Levick&#39;s blog</title>
  
  
  <link href="https://levickcg.github.io/atom.xml" rel="self"/>
  
  <link href="https://levickcg.github.io/"/>
  <updated>2021-03-24T03:02:08.877Z</updated>
  <id>https://levickcg.github.io/</id>
  
  <author>
    <name>Levick Cheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(持续更新)算法分析与设计--部分算法C++实现</title>
    <link href="https://levickcg.github.io/2021/03/19/algorithmInplement/"/>
    <id>https://levickcg.github.io/2021/03/19/algorithmInplement/</id>
    <published>2021-03-19T15:59:03.000Z</published>
    <updated>2021-03-24T03:02:08.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="插入排序Insert-Sort"><a href="#插入排序Insert-Sort" class="headerlink" title="插入排序Insert Sort"></a>插入排序Insert Sort</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><img src="https://media.geeksforgeeks.org/wp-content/uploads/insertionsort.png" alt="插入排序示意图" style="zoom:67%;" /></p><p>Image from <a href="https://www.geeksforgeeks.org/insertion-sort/">geeksforgeeks</a></p><p>在数组中，将无序部分依次插入有序部分，得到一个有序数组。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br><span class="hljs-keyword">int</span> len=nums.size();<br><span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span> || len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">int</span> key=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>key=nums[i];<br>j=i;<br><span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">1</span>) &amp;&amp; (nums[j<span class="hljs-number">-1</span>]&gt;key))&#123;<br>nums[j]=nums[j<span class="hljs-number">-1</span>];<br>j--;<br>&#125;<br>nums[j]=key;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">int</span> tmp;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Please type the array you wat to sort:&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;tmp)&#123;<br>arr.push_back(tmp);<br>&#125;<br>InsertSort(arr);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:arr)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>为了更好地了解排序的过程，在实现过程中可以添加一些排序过程，输出排序中数组的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span></span>&#123;<br><span class="hljs-keyword">int</span> len=nums.size();<br><span class="hljs-keyword">if</span>(len==<span class="hljs-number">0</span>||len==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>tmp=nums[i];<br><span class="hljs-keyword">int</span> j=i;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;The &quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;th round:&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span>( (j&gt;=<span class="hljs-number">1</span>) &amp;&amp; (tmp&lt;nums[j<span class="hljs-number">-1</span>]) )&#123;<br>nums[j]=nums[j<span class="hljs-number">-1</span>];<br>j--;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:nums)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>nums[j]=tmp;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:nums)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>比如我们输入<code>1 5 2 4 3</code>， 结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs reStructuredText">Please type the array you wat to sort:<br>1 5 2 4 3 ^X<br><br>The 1 round:<br>1 5 2 4 3<br><br><br>The 2 round:<br>1 5 5 4 3<br>1 2 5 4 3<br><br><br>The 3 round:<br>1 2 5 5 3<br>1 2 4 5 3<br><br><br>The 4 round:<br>1 2 4 5 5<br>1 2 4 4 5<br>1 2 3 4 5<br><br>Final anwers:<br>1 2 3 4 5<br></code></pre></td></tr></table></figure><h2 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/Merge-Sort-Tutorial.png" alt="归并排序示意图" style="zoom: 80%;" /></p><p>Image from <a href="https://www.geeksforgeeks.org/merge-sort/">geeksforgeeks</a></p><p>“每次遇见了不会的排序时，一定不是自己脑子太笨了，肯定是规模太大了”——Prof.zly </p><p>归并排序采用分治思想，每次近乎二分，规模太大递归继续分，当只剩一个数时，就很容易比较，后递归合并结果。整个过程可以看作是递归搜索树的后序遍历过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> r)</span></span>&#123;<br><span class="hljs-keyword">int</span> len1=m-l+<span class="hljs-number">1</span>, len2=r-m;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr1</span><span class="hljs-params">(len1)</span></span>;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">arr2</span><span class="hljs-params">(len2)</span></span>;<br><span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;len1;i++)&#123;<br>arr1[i]=nums[l+i];<br>&#125;<br><span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;len2;j++)&#123;<br>arr2[j]=nums[m+<span class="hljs-number">1</span>+j];<br>&#125;<br>i=<span class="hljs-number">0</span>;<br>j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> len=r-l+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> k=l;<br><br><span class="hljs-keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2)&#123;<br><span class="hljs-keyword">if</span>(arr1[i]&lt;arr2[j])&#123;<br>nums[k]=arr1[i];<br>i++;<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>nums[k]=arr2[j];<br>j++;<br>&#125;<br>k++;<br>&#125;<br><br><span class="hljs-keyword">while</span>(i&lt;len1)&#123;<br>nums[k]=arr1[i];<br>i++;<br>k++;<br>&#125;<br><span class="hljs-keyword">while</span>(j&lt;len2)&#123;<br>nums[k]=arr2[j];<br>j++;<br>k++;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums,<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;<span class="hljs-comment">//l-&gt;left, r-&gt; right</span><br><span class="hljs-keyword">if</span>(l&gt;=r)&#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">int</span> m=<span class="hljs-built_in">floor</span>((l+r)/<span class="hljs-number">2</span>);<span class="hljs-comment">//m-&gt; middle</span><br>mergesort(nums,l,m);<br>mergesort(nums,m+<span class="hljs-number">1</span>,r);<br>merge(nums,l,m,r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; arr;<br><span class="hljs-keyword">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Please input the array you want to sort:&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">cin</span>&gt;&gt;tmp)&#123;<br>arr.push_back(tmp);<br>&#125;<br>mergesort(arr,<span class="hljs-number">0</span>,arr.size()<span class="hljs-number">-1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span>&amp; x:arr)&#123;<br><span class="hljs-built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文记录了算法分析与设计课中部分算法的代码C++实现。</summary>
    
    
    
    <category term="Algorithm" scheme="https://levickcg.github.io/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="https://levickcg.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>动态规划简介———以Fibonacci数列为例</title>
    <link href="https://levickcg.github.io/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%B0%8F%E7%BB%93/"/>
    <id>https://levickcg.github.io/2021/03/02/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%B0%8F%E7%BB%93/</id>
    <published>2021-03-02T16:00:00.000Z</published>
    <updated>2021-03-20T08:31:56.395Z</updated>
    
    <content type="html"><![CDATA[<p>​        本文从Fibonacci数列的求解来简单介绍动态规划的基本思想与一般解法。</p><h2 id="从Fibonacci数列讲起"><a href="#从Fibonacci数列讲起" class="headerlink" title="从Fibonacci数列讲起"></a>从Fibonacci数列讲起</h2><p>​        Fibonacci数列在各种科目的教材中出现的次数很多，多为引出递归这一思想的样例，大家都比较熟悉，而此处，我用这一例子来阐述动态规划的基本思想、方法。</p><p>我们已知Fibonacci数列性质如下：</p><script type="math/tex; mode=display">F(0)=0, F(1)=1\\F(i)=F(i-1)+F(i-2)\ \ \ \ i=2,3,4,...,n</script><p>一般的<u>递归</u>解法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//假设非法输入返回-1</span><br><span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> F(n<span class="hljs-number">-1</span>)+F(n<span class="hljs-number">-2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​        但是递归的方法显然会出现重复计算（比如计算$F(3)=F(2)+F(1)=(F(1)+F(0))+F(1)$ ,当n更大时，重复计算更多)，时间复杂度为$O((\frac{1+\sqrt{5}}{2})^n)$（时间复杂度的详细计算可以自行搜索），明显不是一个好的算法。</p><h2 id="动态规划——递归-重复值的记录"><a href="#动态规划——递归-重复值的记录" class="headerlink" title="动态规划——递归+重复值的记录"></a>动态规划——递归+重复值的记录</h2><p>​        很明显，改进递归算法的方向之一是减少重复计算，如何解决？我们用数组的形式记录之前已经计算过的值。</p><p>​        通过简单的改进，具有简单递归思想的算法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<span class="hljs-comment">//假设非法输入返回-1</span><br>    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">fib</span><span class="hljs-params">(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    fib[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        fib[i]=fib[i<span class="hljs-number">-1</span>]+fib[i<span class="hljs-number">-2</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> fib[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>​        用<strong>fib</strong>数组来储存之前计算过的斐波那契数，不用再递归求解。由于循环中$i$由小到大，所以我们能够保证在求解$fib[i]$时，$fib[i-1],  fib[i-2]$已经被求解出来。</p><h2 id="动态规划思想简括"><a href="#动态规划思想简括" class="headerlink" title="动态规划思想简括"></a>动态规划思想简括</h2><p>​        所以动态规划的思想可以简单地概括为：</p><script type="math/tex; mode=display">DP=recursion+memorization</script><blockquote><ul><li><p>recursion: 问题本质可以数学化为递归数列的求解，能找到相应的递推公式</p></li><li><p>memorization: 通过数组或其他变量来存储已经计算过的项，减少重复计算</p></li></ul></blockquote><p>所以在 </p><p> 1.对问题最有解法可用于子问题（recursion）。</p><p> 2.子问题与原问题有相交（overlap），且递归的解包含子问题的解且重复多次（可用memorization）。 </p><p>两者同时成立时，可以考虑用DP解决该问题。</p><p>如果理解的话，尝试一下自己能否独立写出$leetcode$上这道$Fibonacci$数列的题呢？</p><p><a href="https://leetcode-cn.com/problems/fibonacci-number/">509-斐波那契数</a></p>]]></content>
    
    
    <summary type="html">本文从Fibonacci数列的求解来简单介绍动态规划的基本思想与一般解法。</summary>
    
    
    
    <category term="Algorithm" scheme="https://levickcg.github.io/categories/Algorithm/"/>
    
    <category term="dynamic programming" scheme="https://levickcg.github.io/categories/Algorithm/dynamic-programming/"/>
    
    
    <category term="Algorithm" scheme="https://levickcg.github.io/tags/Algorithm/"/>
    
    <category term="dynamic programming" scheme="https://levickcg.github.io/tags/dynamic-programming/"/>
    
    <category term="leetcode" scheme="https://levickcg.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>(Updating...)Notes for Linux commands</title>
    <link href="https://levickcg.github.io/2020/03/16/LinuxCommand/"/>
    <id>https://levickcg.github.io/2020/03/16/LinuxCommand/</id>
    <published>2020-03-16T16:00:00.000Z</published>
    <updated>2021-03-21T11:10:29.420Z</updated>
    
    <content type="html"><![CDATA[<p>​        I haven’t have had the chance to systematically study the linux commands, although I have used Linux to finish some tasks in the class. And recently I just found the book <strong><em>The Linux Command Line</em></strong> on the Internet, it’s easy-to-read for non-native English speakers so I decide to read the whole book and make some notes.So this article is the notes of the book <strong><em>The Linux Command Line</em></strong> and other useful commands that I came across. I will try to use simple words to cover the contents of the book by omitting unnecessary sentences.</p><h2 id="Learning-Shell"><a href="#Learning-Shell" class="headerlink" title="Learning Shell"></a>Learning Shell</h2><h3 id="What-is-Shell"><a href="#What-is-Shell" class="headerlink" title="What is Shell?"></a>What is Shell?</h3><p>When we enter the terminal, we see something like :</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">levick@ubuntu:~$<br></code></pre></td></tr></table></figure><p>which represent <code>username@hostname:currentPath$</code>. In this (my) case, my username is $levick$, my hostname(name of the machine) is $ubuntu$, the current path is $ \sim$(home path of  current user), $\$$  -&gt; normal user, # -&gt; super user.</p><blockquote><p>BTW, $/$ represent the root directory of the computer. ( It’s kind of like <strong><em>This PC</em></strong> in <strong>Windows</strong>)</p><p>And, to log in super user, type <code>sudo -s</code>.</p></blockquote><p>some really basic commands:</p><p><code>date</code>: get today’s date.</p><p><code>cal</code>: display the date like a calendar.</p><p><code>df</code>: the current amount of free space on your <strong>disk drives</strong>.</p><p><code>free</code>: display the amount of free <strong>memory</strong>.</p><p>to close the terminal, type<code>exit</code>.</p><h2 id="Change-directory-in-the-File-System"><a href="#Change-directory-in-the-File-System" class="headerlink" title="Change directory in the File System"></a>Change directory in the File System</h2><p>To navigate the file system, we may use following commands.</p><blockquote><ul><li><code>pwd</code>: <del>display your <strong>p</strong>ass<strong>w</strong>or<strong>d</strong></del> display the current directory. (short for <strong>P</strong>rint <strong>W</strong>orking <strong>D</strong>irectory)</li><li><code>file</code>: used as <code>file filename</code>, to check the file format of chosen file.</li><li><code>ls</code>: list the contents of the current directory.</li><li><code>cd</code>: <strong>c</strong>hange <strong>d</strong>irectory, used as <code>cd PathName</code>.</li></ul></blockquote><p><code>pwd</code> and <code>file</code> are simple, while <code>ls</code> and <code>cd</code> can be more complex.</p><h3 id="The-command-cd"><a href="#The-command-cd" class="headerlink" title="The command cd"></a>The command <code>cd</code></h3><p><code>cd</code> is what we use all the time, because we have to change the directory constantly.  The are 2 different methods to represent <code>Path</code>——–&gt;<strong><em>absolute pathname</em></strong> or <strong><em>relative pathname</em></strong>. </p><blockquote><p><strong><em>absolute pathname</em></strong>: starts from the root directory and leads to its destination</p><p><strong><em>relative pathname</em></strong>: starts from the working directory, uses <code>.</code> to represent the working directory and <code>..</code> to represent the parent directory of the working directory.</p></blockquote><p>Even more , we can change the working directory easily with following shortcut.</p><div class="table-container"><table><thead><tr><th style="text-align:left">Shortcut</th><th>Result</th></tr></thead><tbody><tr><td style="text-align:left">cd</td><td>go to the home directory</td></tr><tr><td style="text-align:left">cd -</td><td>go to the previous directory</td></tr><tr><td style="text-align:left">cd ~user-name</td><td>go to the home directory of the “user-name”</td></tr></tbody></table></div><h2 id="Cases-I-Came-across"><a href="#Cases-I-Came-across" class="headerlink" title="Cases I Came across"></a>Cases I Came across</h2><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><h4 id="Replace-string-that-contains-or"><a href="#Replace-string-that-contains-or" class="headerlink" title="Replace string that contains \(or  /)"></a>Replace string that contains <code>\</code>(or  <code>/</code>)</h4><p>​                We know that in command mode we use <code>:%s/string1/string2/g</code> to replace string1 with string2 globally.(Note that <code>/</code> here is a delimiter) But when we need to replace string that contains <code>\</code> or <code>/</code>, it’s a bit tricky. In general, there are two ways to do it.</p><p>​                For example, we want replace all the <code>\</code>  with <code>/</code>  (when you want to convert path from <strong>Windows</strong> to <strong>Linux</strong>)</p><blockquote><ul><li>escape the <code>/</code>, use <code>:%s/\\/\//g</code>. From the first slash to the last slash, they are: <strong>delimiter, escape character, character, delimiter, escape character, character, delimiter</strong>.<br>In this case we use <code>/</code> as a delimiter, so if we don’t want to mix up delimiter <code>/</code> and the character <code>/</code>, we use <code>\/</code> to escape <code>/</code>  the delimiter to <code>/</code> the character.</li><li>use another delimiter, like <code>#</code> or <code>@</code>, use <code>:%s#\\#/#g</code>. From the first slash to the last slash, they are: <strong>escape character, character, character</strong>. But note that you can’t use <code>|</code>, <code>\</code>,<code>&quot;</code> as a separator. </li></ul><p>Note that in both cases we escape <code>\</code> (the default escape character) as <code>\\</code> when we want to use it as a character.</p></blockquote><p>​                Always be ware of the structure of the command, distinguish <strong><em>delimiter</em></strong> , <strong><em>escape character</em></strong> and normal <strong><em>character</em></strong>.</p>]]></content>
    
    
    <summary type="html">This article is the notes of the book The Linux Command Line and other useful commands that I came across.</summary>
    
    
    
    <category term="Linux" scheme="https://levickcg.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://levickcg.github.io/tags/Linux/"/>
    
    <category term="vim" scheme="https://levickcg.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
